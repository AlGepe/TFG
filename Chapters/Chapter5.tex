\chapter{TRACS: the meats and potatoes of this whole thing}
% I'm missing the general approximations made in TRACS such as no electron-electron interaction
\label{chap:Comp}

We have already stated the importance of simulating software in research in general and in radiation damage studies in particular, so it should come as no surprise that this next chapter is entirely dedicated to the software developed during this project. When talking about simulation software one can usually classify them in two big categories: fast light-weight approximate simulators and slow, powerful, accurate simulators. Both of them have their strengths and weaknesses with the latter group being often used for theory orientated checks and the fast simulators commonly used for measurement comparison in laboratory situations.

For the purposes of this project we will shift out focus to the fast and light-weight simulators for that is the kind of simulation software that was upgraded during this project. That is not to say that slow accurate simulators are not useful for the project, on the contrary both software types can complement each other in many scenarios, but are not of crucial importance for the project itself.

In the silicon detector simulation field, specially amongst members of the RD-50 collaboration from CERN, there were several already available simulators capable of reproducing TCT measurements from the laboratory for different detector configurations (diode, micro-strips\ldots) as well as some other features specific to each individual software. The software of choice for this project was the Transient Current Simulator (TRACS) developed by Pablo De Castro in 2014 in the PH-DT-DD-SSD group at CERN. 

The reasoning behind the decision of using TRACS is pretty straight forwards and was based on two principal arguments. First one is that TRACS is an open-software platform built around efficient open-software libraries that have been already tested and validated in multiple scenarios. And second and probably more important is that the software TRACS was already developed and used in the PH-DT-DD-SSD group where this upgrade project was developed which means it was also designed with future upgrades in mind. 

In this chapter we will present the structural design of the software as it was before the project started including the different parts in which it is divided. We will also present the changes and upgrades performed with particular emphasis on the implementation of radiation damage simulation including the rationale behind the decisions and simplifications made in the process. Lastly we shall comment briefly on where the software stands now, after the upgrades, and what the forseenable future might hold for TRACS from a wider perspective.

\section{Software design} % (fold)
\label{sec:results_and_achievements}

TRACS is built and written in C++11 standard and makes use of Fenics and Boost libraries for calculations and Qt and VTK for GUI, plotting and visualisation. The whole software takes advantage of Object Oriented Programming and it is, thus, organised in different classes following a logic similar to the real world process. TRACS also has two different modes available for the user: a command line interface (CLI) and a Graphical User Interface (GUI) both of which will be explained in detail later in this section.

During a typical simulation on TRACS, the program would take detector properties and carrier position. TRACS then solves Poisson's equation for the given conditions to obtain the electric field. This part is done using the aforementioned Fenics libraries taking advantage of its efficient PDE solver. Then the carriers are drifted inside the detector using the electric field obtained in the step before and Ramo's theorem to calculate the induced signal in the circuit. Data of the waveform is then saved and stored in both plain text and ROOT format.

This \textit{modus operandi} was present in the original version of TRACS an still remains at the core of every simulation performed using the software. Alterations to the code and behaviour of the program will be addressed in the following section together with the justification for all the decisions that were made. Now we will briefly summarise the different parts that compose TRACS from its original state to the latest upgrade.

\subsection{detector module and PDE solver}

One of the core modules of TRACS is the one composed by the detector class and PDE solver. This is composed fundamentally of the \textit{SMSDetector} class and the \textit{SMSDSubDomains}. In these classes the properties of the detector are stored and converted into boundary conditions for Poisson's equation to be solved on them. The PDE solving algorithm is fully provided by Fenics libraries and the configuration done through \textit{Poisson.h} and \textit{Gradient.h} files.

If several simulations are to be performed using the same detector and initial conditions, the fields and potentials need not be calculated again for they are saved in memory by TRACS. 

This part of the software is flexible enough to accommodate for any detector geometry with few changes in the code, thanks to the use of Fenics libraries. For diodes and micro-strip, however, the software is readout simulated them out-of-the-box as diodes are considered a special case of micro-strips with just one strip covering the whole surface of the silicon.

It is in this part of the software that the \neff is implemented through the $V_{dep}$ for the non-irradiated case. Several modifications were done in TRACS to extend its capabilities of simulation to a radiation-modified \neff parametrisation decided by the user. We will explain all the modifications to this part in detail in the next section as we go through the modifications performed to TRACS.


\subsection{Drifting}

After the electric field and potential and the weighting field and potential have been calculated, the software then proceeds to move the charge carriers inside the detector according to the correspondent laws of movement. This is taken care by the classes: \textit{CarrierCollection}, \textit{Carrier},\textit{CarrierMobility}, \textit{CarrierTransport}

The charge carriers are input via a plain text file containig one carrier per line with initial position (in the 2-D section of the detector), the off-set time at which they should be generated in the simulation, and the equivalent charge they carry. The carriers can be read and stored for every simulation or moved about the detector if needed. The current is calculated using Ramo's theorem for every carrier and added together for every time step.

The off-set generation time introduced as an input is a quantity whose actual value is of no significance and it is only introduced to reproduce better the waveforms obtained in the lab, specially the first spike that appears as the carriers are created and the signal in the circuit starts to be collected. This off-set also helps obtaining better results when one wishes to simulate the electronic shaping of the signal or even more sophisticated stuff like more accurately timed charge carriers creation.

% maybe use equations here?
An important feature of the TRACS carriers simulation is the grouping and splitting of carriers by assignment of a weighted charge. This means that groups of charge carriers  of the same type, lying initially very close together can be simulated as being just one charge carrier with a total charge equal to the sum of all the individual charges of the carriers. This reduces greatly the number of individual charge carriers that need to be simulated hence improving simulation times. This grouping can be done with almost no penalty in precision of the results due to the neglect of carrier-carrier interactions.

Simulating the movement of carriers inside the detector requires to solve a first order equation. That is taken care by Runge-Kutta-4 method implemented inside ODEINT libraries. ODEINT libraries now come as a standard part of BOOST libraries inside C++11. These libraries, together with Fenics, ensure fast, efficient and robust computational properties at the core algorithms and free developers to focus on more physics and silicon detector related problems.



\subsection{joining all together (CLI)}

To bring all the components together TRACS has both a CLI and a GUI available to the user. They both fulfil different needs and are suited for very different use case scenarios. As such we shall focus now on the CLI part to later explain the GUI together with their main features and differences.

TRACS is designed around two main use case scenarios: quick checks and long simulations. For the latter case CLI was designed, providing the user with and easy, low resource execution version, that can be easily automated. The CLI executable for TRACS was born as the proof-of-concept and grew into a fully functional standalone version, even though that has changed through the course of the project.

\subsection{GUI and its advantages}

On top of the already mentioned CLI, TRACS also provides a GUI to allow for easy checks and a more user-friendly approach to simulations. The GUI is built with ease of use in mind instead of high efficiency performance for long simulations. It is thus divided in different tabs for each of the different components of TRACS, and every tab contains several graphs and visualisation options to make everything easy to understand and use.

First tab allows the user to configure all the detector parameters and solve the PDEs for the specific detector parameters. After resolution of the PDEs, all the potentials and fields are plotted inside the potentials tab and the fields tab respectively. The graphs offer colour-coded 2D maps as well as 1D cut of the fields; interactive 3D plots are also available through VTK tools.

The other two tabs that conform the GUI are used for carrier drifting and waveform simulation. Options range from 1 carrier simulations, to simulating a line of carriers to full laser illumination simulations (provided the correct file). All these tools are equipped with carrier visualisation tools as well as a waveform plotting area for quickly checking the shapes and general features. On top of these visualisation-oriented features, TRACS-GUI also provides a way to save the waveforms in plain text format.

\section{The development phase, changes and rationale} % (fold)
\label{sec:werk}

All the modules and features we have explained in the previous section were part of the original TRACS software. From that point the software was modified and upgraded to include radiation damage effects  with user defined parameters as well as improving the usage and flexibility of TRACS both as a standalone and as a library-like module for bigger projects.

All the changes made during this project were oriented to either the main goal: Implementing radiation damage into the simulations; or future extensibility of TRACS capabilities. These future oriented features will be commented briefly since they are not a fundamental part of the project and most of the information regarding them will lay under future projection or future upgrades proposal.

The radiation damage effects that were implemented and represent the core of the project will be explained in detail with detailed explanations on the specific decisions that were made and how the implementation was done. This will be separated in two parts dividing the physics part and rationale from the coding and software design part of the whole implementation.

\subsection{What we changed}

The different effects of radiation damage in the signal obtained from a silicon detector have been discussed before and we concluded that a part from the increase in $V_{dep}$ and leakage current, the main effects were the loss in charge collection efficiency and the modification in the shape of the waveform due to the perturbated \neff. It is important to remember that even though we treat these effects as different, they are all the result of the Vacancy-Interstitial defects in the lattice due to particle-Si core collisions.

For TRACS simulation capabilities, the increase in leakage current needs not be taken into account. This leaves only increase in $V_{dep}$, \neff modification and trapping of carrier to be implemented inside the code. The increase in $V_{dep}$ can be included in the \neff modification since $V_{dep}$ is dependant on the \neff inside the detector so that by solving the PDEs for the modified \neff one should automatically obtain the correct $V_{dep}$ value.

The \neff modification is, as we have already discussed, a rather complicated effect to implement in a simulator software like TRACS that cannot reproduce the irradiation process. It is then required to have a model for how the \neff get distorted from the original constant value as a function of radiation fluence. There is not such a model that works satisfactory for wide range of fluences, which leaves room for custom solutions. 

It is important to know that one of the ultimate goals of the bigger TRACS project is to be used as part of a fitting tool that would take waveforms of irradiated silicon detectors as input and return the \neff configuration that yields the closest results. This way TRACS would greatly diverge from current silicon detector simulators in such a way that it can get information about the detector retrospectively on top of performing approximate simulation-prediction of what the results should be.

This simplifies greatly the implementation process as it is not needed to use any approximate model that would parametrise trapping and \neff modification effects as a function of the radiation fluence the silicon detector has be subject to. This models often require multiple experimental coefficients that may vary under different conditions and one might end up needing to use several different models to fully parametrise just one physical value. The approach taken in this project sits on the opposing end, rendering TRACS viable to be used as another analysis tool as well as a guessing/comparing tool.

With this goal in mind the reasoning behind the parametrisation should be easier to comprehend. A decision was made to include both \neff parametrisations mentioned as the most widespread ones. The first parametrisation, the linear approximation, is easy to implement and has only 2 free parameters that would need adjusting or knowing beforehand depending on the scenario. Since this parametrisation has given good results in modelling \neff modification in irradiated silicon detectors throughout different research studies, it will used as the most basic and easy to use and implement approximation for radiation damage.

Since TRACS might be used in part of a fitting process it is key to have flexibility as to how the \neff will be defined and for improving the adaptability of TRACS to any possible \neff distribution, it was decided to include as well a more exotic \neff parametrisation in the form of a mixture between the previously mentioned parametrisations. The extra modelling of the \neff that has been included into TRACS consists on 3 different areas where the carrier density is linear with depth. Restrictions are imposed in the allowed values for each zone so that continuity is ensured. 

Those are not the only restrictions imposed on the \neff. In the linear approximation, continuity and derivability are guaranteed, continuity in the triple linear approximation is forced but derivability is not guaranteed; and for the triple constant approximation continuity and derivability are not ensured. Derivability, though not strictly necessary for current use of TRACS, has been ensured in both triple linear and triple constant approximations by means of hyperbolic tangents connecting the end of one area with the beginning of the adjacent one. Continuity in the triple constant approximation arises from these hyperbolic tangent bridges that connect smoothly one value of the \neff in one area to the vale in the next. 


With \neff parametrisation already solved and explained we must now turn our attention to the trapping effects as the second feature to implement for the simulation of irradiated silicon detectors. Trapping of charge carriers is a statistical process and as such cannot it shall require a random variable as control for each carrier with the corresponding performance penalty, specially for low trapping probabilities and high number of carriers.

To avoid such computational overhead, we opted for the approximated implementation of the effect through the use of an exponential wrapping over the whole waveform. This approximation requires enough siumulated time and enough carriers to be simulated to be relatively accurate. Both conditions are met by all but the most extreme of the scenarios simulating real world measurements. We have discussed before the validity of the exponential approach to statistical processes as in the case of carrier trapping. It is then not needed to do it again.

The last of the updgrades to TRACS with physical relevance for the simulations was the inclusion of rigurous electronics shaping simulation. TRACS had basic lowpass filter shaping as an option in CLI version but that was not good enough for detailed comparisons. The decision made was to implement a way to get a real-world electronics shapping by convoluting the raw signal from the simulation with the amplifier transfer function. This transfer function depends heavily on the amplifier and setup used so it was decided to be kept as input data.

On top of the improvements we have mentioned, that were oriented mainly to include radiation damage into the simulations, some other features have been implemented with focus on user experience or future development of TRACS. These features are of less importances for the research project but equally important for TRACS and its future projection. 

A common charasteristic of these \textit{side features}, as we may call them, is that none of them increase performance, accuracy\ldots of TRACS but make it easier to be used, modified, understood\ldots Amongst these features we can find improvements such as better comments and code clean-up and the improvements on the README text file that includes now a more detailed installation guide as well as a quick-guide for the most typical use case scenarios.  Also a configuration file was added to the code, together with the necessary \textit{parser}, eliminating the need for recompilation everytime an input value is changed, and making it possible for users to change simulation parameters in CLI without the need to dig into the code. 

The last addition to TRACS is one that had always been in TRACS' roadmap but only as the generic idea that TRACS should be able to be used and integrated into bigger pieces of software (e.g.: ROOT) as a library package. This lead to the development of \textit{TRACSInterface}, a class that acts as the bridge between any software and TRACS and allows said software to leverage TRACS capabilites through a very simple set of methods that encapsulate and simplify all functionalities of TRACS.

The \textit{TRACSInterface} class contains a simple set of methods that allows the user to read the input values from the configuration file, modify those parameters and perform every step of the whole simulation as well as returning those results. This means that TRACS can be used as a simple layer over Fenics for calculating electrical properties of silicon detectors, perform a non-standard set of simulations (odd shifts of carriers arround the detector) and obtain the resulting waveforms of a normal TRACS simulation with and without electronics shaping.

\subsection{How we implemented the stuff we implemented}

Implementation of the improvements in TRACS can be seen as a fairly straight-forward process due to the usage of Object Oriented programming and external flexible libraries. In the case of modified \neff implementation Fenics libraries prodive users with the option to define a custom space charge distribution to solve Poisson's equation. 

By creating a new class \textit{Source} the \neff could be parametrised in the chosen manners, including the option for the user to select between different parametrisations during execution time. Inside the class setter methods were also implemented so that \neff approximation and parametrisation can be modified \textit{on-the-fly}. By having a dedicated class for \neff parametrisation TRACS can also be easily modified to include any other parametrisation should  it be needed at some point. 

In the implementation of trapping effects was performed in a very simple manner. Its implementation clearly reflects the computational advantage of the chosen approach compared to the physically more accurate. For the implementation of the exponential wrapping of the waveform it suffices to multiply the raw values in each time step by the exponential factor at the given time. This simulates the effect of the statistical trapping and yields an exponential decrease in the output current that mimics the experimental one.

For both \neff parametrisation and trapping effects, it is needed for the user to introduce the relevant parameters. For the custom \neff effect the input data are the coordinates of the points needed to define the selected \neff parametrisation. The number of parameters needed in each case varies from 2 for the linear case to 5 for the triple constant \neff to 6 for the case of triple linear approximation. In the case of trapping effects, only one parameter is needed: \tau.

The side features implemented are spread around the whole code of TRACS, specially the cleaning and commenting side of it. For the configuration file a new file \textit{Config.TRACS} was added with its very own syntax that allows the parser to identify input values from comments and explanations. The \textit{TRACSInterface} development was done, as previously stated, on a new separate class in addition to the already present CLI and GUI so that nothing had to be change for standalone use of TRACS.

As well as the code and CLI, the GUI version of TRACS has also been upgraded to account and make use of the changes for simulating irradiated detectors as well as all the side features implemented for a better user experience. This changes include the extra fields to input the new parameters such as \neff parametrisation type and coordinates, trapping time and a toggle to switch between simulation of irradiated detectors (taken \neff parameters and trapping time into account a disposing off $V_{dep}$) or non-irradiated detectors ($V_{dep}$ will define the constant vale of \neff and trapping time will not be considered). 

It is an unintended feature of TRACS that you can de-couple \neff modification and trapping effects allowing the user to explore both effects separately by simply toggling on radiation simulation and inputing a constant \neff or a very big trapping time (i.e.: effectively no trapping). Other improvements to TRACS-GUI include the implementation of simple on-the-fly RC shapping capabilites for output waveforms as well as resizeable plot throgout all tabs. The last of the visual improvements to TRACS is the inclussion of the Custom N$_{eff}$ Visualization Tool (CNVT) which allows the user to preview the \neff configuration before starting the simulation.

In summary, TRACS has been improved and upgraded to include radiation effects into the simulations with user defined \neff and trapping parameters. On top of those improvements TRACS has also seen an overhault in terms of documentation, user experience and flexibility being able now to be run as an aditional library or module on a bigger piece of software.

As scientific procedure dictates, these improvement are of no use until they are contrasted and tested agains real-world data. The original version of TRACS showed excellent agreement with experimental data from laboratory measurements so it is expected that the new version of TRACS be a useful and accurate tool. This accuracy will be tested in the next section, that will prove TRACS usefulness as a research tool for anyone intereseted in radiation damage in silicon detectors.

% section let_s_put_the_project_in_perspective (end)
