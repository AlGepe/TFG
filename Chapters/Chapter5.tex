\chapter{TRACS: the meats and potatoes of this whole thing}
% I'm missing the general approximations made in TRACS such as no electron-electron interaction
\label{chap:Comp}

We have already stated the importance of simulating software in research in general and in radiation damage studies in particular, so it should come as no surprise that this next chapter is entirely dedicated to the software developed during this project. When talking about simulation software one can usually classify them in two big categories: fast light-weight approximate simulators and slow, powerful, accurate simulators. Both of them have their strengths and weaknesses with the latter group being often used for theory orientated checks and the fast simulators commonly used for measurement comparison in laboratory situations.

For the purposes of this project we will shift out focus to the fast and light-weight simulators for that is the kind of simulation software that was upgraded during this project. That is not to say that slow accurate simulators are not useful for the project, on the contrary both software types can complement each other in many scenarios, but are not of crucial importance for the project itself.

In the silicon detector simulation field, specially amongst members of the RD-50 collaboration from CERN, there were several already available simulators capable of reproducing TCT measurements from the laboratory for different detector configurations (diode, micro-strips\ldots) as well as some other features specific to each individual software. The software of choice for this project was the Transient Current Simulator (TRACS) developed by Pablo De Castro in 2014 in the PH-DT-DD-SSD group at CERN. 

The reasoning behind the decision of using TRACS is pretty straight forwards and was based on two principal arguments. First one is that TRACS is an open-software platform built around efficient open-software libraries that have been already tested and validated in multiple scenarios. And second and probably more important is that the software TRACS was already developed and used in the PH-DT-DD-SSD group where this upgrade project was developed which means it was also designed with future upgrades in mind. 

In this chapter we will present the structural design of the software as it was before the project started including the different parts in which it is divided. We will also present the changes and upgrades performed with particular emphasis on the implementation of radiation damage simulation including the rationale behind the decisions and simplifications made in the process. Lastly we shall comment briefly on where the software stands now, after the upgrades, and what the forseenable future might hold for TRACS from a wider perspective.

\section{Software design} % (fold)
\label{sec:results_and_achievements}

TRACS is built and written in C++11 standard and makes use of Fenics and Boost libraries for calculations and Qt and VTK for GUI, plotting and visualisation. The whole software takes advantage of Object Oriented Programming and it is, thus, organised in different classes following a logic similar to the real world process. TRACS also has two different modes available for the user: a command line interface (CLI) and a Graphical User Interface (GUI) both of which will be explained in detail later in this section.

During a typical simulation on TRACS, the program would take detector properties and carrier position. TRACS then solves Poisson's equation for the given conditions to obtain the electric field. This part is done using the aforementioned Fenics libraries taking advantage of its efficient PDE solver. Then the carriers are drifted inside the detector using the electric field obtained in the step before and Ramo's theorem to calculate the induced signal in the circuit. Data of the waveform is then saved and stored in both plain text and ROOT format.

This \textit{modus operandi} was present in the original version of TRACS an still remains at the core of every simulation performed using the software. Alterations to the code and behaviour of the program will be addressed in the following section together with the justification for all the decisions that were made. Now we will briefly summarise the different parts that compose TRACS from its original state to the latest upgrade.

\subsection{detector module and PDE solver}

One of the core modules of TRACS is the one composed by the detector class and PDE solver. This is composed fundamentally of the \textit{SMSDetector} class and the \textit{SMSDSubDomains}. In these classes the properties of the detector are stored and converted into boundary conditions for Poisson's equation to be solved on them. The PDE solving algorithm is fully provided by Fenics libraries and the configuration done through \textit{Poisson.h} and \textit{Gradient.h} files.

If several simulations are to be performed using the same detector and initial conditions, the fields and potentials need not be calculated again for they are saved in memory by TRACS. 

This part of the software is flexible enough to accommodate for any detector geometry with few changes in the code, thanks to the use of Fenics libraries. For diodes and micro-strip, however, the software is readout simulated them out-of-the-box as diodes are considered a special case of micro-strips with just one strip covering the whole surface of the silicon.

It is in this part of the software that the \neff is implemented through the $V_{dep}$ for the non-irradiated case. Several modifications were done in TRACS to extend its capabilities of simulation to a radiation-modified \neff parametrisation decided by the user. We will explain all the modifications to this part in detail in the next section as we go through the modifications performed to TRACS.


\subsection{Drifting}

After the electric field and potential and the weighting field and potential have been calculated, the software then proceeds to move the charge carriers inside the detector according to the correspondent laws of movement. This is taken care by the classes: \textit{CarrierCollection}, \textit{Carrier},\textit{CarrierMobility}, \textit{CarrierTransport}

The charge carriers are input via a plain text file containig one carrier per line with initial position (in the 2-D section of the detector), the off-set time at which they should be generated in the simulation, and the equivalent charge they carry. The carriers can be read and stored for every simulation or moved about the detector if needed. The current is calculated using Ramo's theorem for every carrier and added together for every time step.

The off-set generation time introduced as an input is a quantity whose actual value is of no significance and it is only introduced to reproduce better the waveforms obtained in the lab, specially the first spike that appears as the carriers are created and the signal in the circuit starts to be collected. This off-set also helps obtaining better results when one wishes to simulate the electronic shaping of the signal or even more sophisticated stuff like more accurately timed charge carriers creation.

% maybe use equations here?
An important feature of the TRACS carriers simulation is the grouping and splitting of carriers by assignment of a weighted charge. This means that groups of charge carriers  of the same type, lying initially very close together can be simulated as being just one charge carrier with a total charge equal to the sum of all the individual charges of the carriers. This reduces greatly the number of individual charge carriers that need to be simulated hence improving simulation times. This grouping can be done with almost no penalty in precision of the results due to the neglect of carrier-carrier interactions.

Simulating the movement of carriers inside the detector requires to solve a first order equation. That is taken care by Runge-Kutta-4 method implemented inside ODEINT libraries. ODEINT libraries now come as a standard part of BOOST libraries inside C++11. These libraries, together with Fenics, ensure fast, efficient and robust computational properties at the core algorithms and free developers to focus on more physics and silicon detector related problems.



\subsection{joining all together (CLI)}

To bring all the components together TRACS has both a CLI and a GUI available to the user. They both fulfil different needs and are suited for very different use case scenarios. As such we shall focus now on the CLI part to later explain the GUI together with their main features and differences.

TRACS is designed around two main use case scenarios: quick checks and long simulations. For the latter case CLI was designed, providing the user with and easy, low resource execution version, that can be easily automated. The CLI executable for TRACS was born as the proof-of-concept and grew into a fully functional standalone version, even though that has changed through the course of the project.

\subsection{GUI and its advantages}

On top of the already mentioned CLI, TRACS also provides a GUI to allow for easy checks and a more user-friendly approach to simulations. The GUI is built with ease of use in mind instead of high efficiency performance for long simulations. It is thus divided in different tabs for each of the different components of TRACS, and every tab contains several graphs and visualisation options to make everything easy to understand and use.

First tab allows the user to configure all the detector parameters and solve the PDEs for the specific detector parameters. After resolution of the PDEs, all the potentials and fields are plotted inside the potentials tab and the fields tab respectively. The graphs offer colour-coded 2D maps as well as 1D cut of the fields; interactive 3D plots are also available through VTK tools.

The other two tabs that conform the GUI are used for carrier drifting and waveform simulation. Options range from 1 carrier simulations, to simulating a line of carriers to full laser illumination simulations (provided the correct file). All these tools are equipped with carrier visualisation tools as well as a waveform plotting area for quickly checking the shapes and general features. On top of these visualisation-oriented features, TRACS-GUI also provides a way to save the waveforms in plain text format.

\section{The development phase, changes and rationale} % (fold)
\label{sec:werk}

All the modules and features we have explained in the previous section were part of the original TRACS software. From that point the software was modified and upgraded to include radiation damage effects  with user defined parameters as well as improving the usage and flexibility of TRACS both as a standalone and as a library-like module for bigger projects.

All the changes made during this project were oriented to either the main goal: Implementing radiation damage into the simulations; or future extensibility of TRACS capabilities. These future oriented features will be commented briefly since they are not a fundamental part of the project and most of the information regarding them will lay under future projection or future upgrades proposal.

The radiation damage effects that were implemented and represent the core of the project will be explained in detail with detailed explanations on the specific decisions that were made and how the implementation was done. This will be separated in two parts dividing the physics part and rationale from the coding and software design part of the whole implementation.

\subsection{What we changed}

The different effects of radiation damage in the signal obtained from a silicon detector have been discussed before and we concluded that a part from the increase in $V_{dep}$ and leakage current, the main effects were the loss in charge collection efficiency and the modification in the shape of the waveform due to the perturbated \neff. It is important to remember that even though we treat these effects as different, they are all the result of the Vacancy-Interstitial defects in the lattice due to particle-Si core collisions.

For TRACS simulation capabilities, the increase in leakage current needs not be taken into account. This leaves only increase in $V_{dep}$, \neff modification and trapping of carrier to be implemented inside the code. The increase in $V_{dep}$ can be included in the \neff modification since $V_{dep}$ is dependant on the \neff inside the detector so that by solving the PDEs for the modified \neff one should automatically obtain the correct $V_{dep}$ value.

The \neff modification is, as we have already discussed, a rather complicated effect to implement in a simulator software like TRACS that cannot reproduce the irradiation process. It is then required to have a model for how the \neff get distorted from the original constant value as a function of radiation fluence. There is not such a model that works satisfactory for wide range of fluences, which leaves room for custom solutions. 

It is important to know that one of the ultimate goals of the bigger TRACS project is to be used as part of a fitting tool that would take waveforms of irradiated silicon detectors as input and return the \neff configuration that yields the closest results. This way TRACS would greatly diverge from current silicon detector simulators in such a way that it can get information about the detector retrospectively on top of performing approximate simulation-prediction of what the results should be.

This simplifies greatly the implementation process as it is not needed to use any approximate model that would parametrise trapping and \neff modification effects as a function of the radiation fluence the silicon detector has be subject to. This models often require multiple experimental coefficients that may vary under different conditions and one might end up needing to use several different models to fully parametrise just one physical value. The approach taken in this project sits on the opposing end, rendering TRACS viable to be used as another analysis tool as well as a guessing/comparing tool.

With this goal in mind the reasoning behind the parametrisation should be easier to comprehend. A decision was made to include both \neff parametrisations mentioned as the most widespread ones. The first parametrisation, the linear approximation, is easy to implement and has only 2 free parameters that would need adjusting or knowing beforehand depending on the scenario. Since this parametrisation has given good results in modelling \neff modification in irradiated silicon detectors throughout different research studies, it will used as the most basic and easy to use and implement approximation for radiation damage.

Since TRACS might be used in part of a fitting process it is key to have flexibility as to how the \neff will be defined and for improving the adaptability of TRACS to any possible \neff distribution, it was decided to include as well a more exotic \neff parametrisation in the form of a mixture between the previously mentioned parametrisations. The extra modelling of the \neff that has been included into TRACS consists on 3 different areas where the carrier density is linear with depth. Restrictions are imposed in the allowed values for each zone so that continuity is ensured. Derivability, though not strictly necessary for current use of TRACS, has been ensured by means of hyperbolic tangents connecting the end of one area with the beginning of the adjacent one.
trapping -> exponential decay

UX -> config file, API like, cleaned code, documentation and 


\subsection{How we implemented the stuff we implemented}

due to fenics flexibility it was very easy to implement any \neff

user input parameters

visualization tool

for trapping we multiply the I(t) by and exp(f(t))  yielding similar results to experiments

GUI all the changes




% section let_s_put_the_project_in_perspective (end)
